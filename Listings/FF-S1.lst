C51 COMPILER V9.59.0.0   FF_S1                                                             03/18/2021 08:53:31 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE FF_S1
OBJECT MODULE PLACED IN .\Objects\FF-S1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE FF-S1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\FF-
                    -S1.lst) TABS(2) OBJECT(.\Objects\FF-S1.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // TP5.c
   3          //-----------------------------------------------------------------------------
   4          // AUTH: 
   5          // DATE: 
   6          //
   7          // Target: C8051F02x
   8          // Tool chain: KEIL Microvision 4
   9          //
  10          //-----------------------------------------------------------------------------
  11          #include <C8051F020.h>
  12          #include "c8051F020_SFR16.h"
  13          #include "FF-S1_Config.h"
  14          #include "FF-S1_Divers.h"
  15          #include <stdlib.h>
  16          
  17          unsigned char Intensite=80; //On met à 20% comme valeur d'exemple
  18          unsigned char Lum_ON=10;
  19          unsigned char Lum_OFF=20;
  20          unsigned char Lum_Nbre=10;
  21          int currentNum = 0;
  22          int one_cs = 20828; //Nombre de cycles processeur pour attendre 1cs.
  23          int cptON = 0;
  24          int cptOFF = 0;
  25          int divTimer = 0;
  26          int t_on = 0;
  27          int t_off = 0;
  28          int cpt = 0;
  29          
  30          sbit LED = P1^6;
  31          int i=1;
  32          int k=0;
  33          
  34          char xdata buffer[5];
  35          
  36          #define Reset_Timer3Overflow TMR3CN &= 0x04
  37          #define Disable_Timer3 TMR3CN = 0x00
  38          // Prototypes de Fonctions
  39          void Reception(void){
  40   1        
  41   1          while (RI0 == 0)
  42   1            
  43   1          while (buffer[k] != '\r'){
  44   2            RI0 = 0;
  45   2            REN0 = 0;     //desactive reception
  46   2            buffer[k] = SBUF0;
  47   2            REN0 = 1; //active reception pour next msg
  48   2            k++;
  49   2          }
  50   1          buffer[k] = '\0';
  51   1          Intensite = atoi(buffer);
  52   1          k=0;
  53   1      
  54   1          while (RI0 == 0)
C51 COMPILER V9.59.0.0   FF_S1                                                             03/18/2021 08:53:31 PAGE 2   

  55   1            
  56   1          while (buffer[k] != '\r'){
  57   2            RI0 = 0;
  58   2            REN0 = 0;     //desactive reception
  59   2            buffer[k] = SBUF0;
  60   2            REN0 = 1; //active reception pour next msg
  61   2            k++;
  62   2          }
  63   1          buffer[k] = '\0';
  64   1          Lum_ON = atoi(buffer);
  65   1          k=0;
  66   1      
  67   1          while (RI0 == 0)
  68   1            
  69   1          while (buffer[k] != '\r'){
  70   2            RI0 = 0;
  71   2            REN0 = 0;     //desactive reception
  72   2            buffer[k] = SBUF0;
  73   2            REN0 = 1; //active reception pour next msg
  74   2            k++;
  75   2          }
  76   1          buffer[k] = '\0';
  77   1          Lum_OFF = atoi(buffer);
  78   1          k=0;
  79   1          
  80   1          while (RI0 == 0)
  81   1            
  82   1          while (buffer[k] != '\r'){
  83   2            RI0 = 0;
  84   2            REN0 = 0;     //desactive reception
  85   2            buffer[k] = SBUF0;
  86   2            REN0 = 1; //active reception pour next msg
  87   2            k++;
  88   2          }
  89   1          buffer[k] = '\0';
  90   1          Intensite = atoi(buffer);
  91   1          k=0;    
  92   1          
  93   1          while (RI0 == 0)
  94   1          while (buffer[k] != '\r'){
  95   2            RI0 = 0;
  96   2            REN0 = 0;     //desactive reception
  97   2            buffer[k] = SBUF0;
  98   2            REN0 = 1; //active reception pour next msg
  99   2            k++;
 100   2          }
 101   1          buffer[k] = '\0';
 102   1          Lum_Nbre = atoi(buffer);
 103   1          k=0;
 104   1          
 105   1          EIE2 |= 0x01;
 106   1      }
 107          void Lumiere(unsigned char Intensite,unsigned char Lum_ON,unsigned char Lum_OFF,unsigned char Lum_Nbre){
 108   1        //Gestion de l'intensité
 109   1        t_on = one_cs*(Intensite/100.0);
 110   1        t_off = one_cs - t_on;
 111   1          if (currentNum != Lum_Nbre && Lum_ON != 0 && cptON != 20*Lum_ON){
 112   2            //On garde allumé (à l'intensité qu'on veut) pendant Lum_ON décisecondes
 113   2            cptON++;
 114   2            if(LED) {
 115   3              TMR3RL = 0xFFFF - t_on; //Variable avec Intensite
 116   3          }
C51 COMPILER V9.59.0.0   FF_S1                                                             03/18/2021 08:53:31 PAGE 3   

 117   2            else if (t_off != 0) {
 118   3              TMR3RL = 0xFFFF - t_off;
 119   3          }
 120   2          //Générateur de signaux
 121   2          LED = !LED;
 122   2          Reset_Timer3Overflow;
 123   2          cptOFF = 0; //Reset du compteur de Lum_OFF pour son prochain allumage
 124   2          return ;
 125   2        }
 126   1          else if (currentNum != Lum_Nbre && Lum_OFF != 0 && cptOFF != 20*Lum_OFF){
 127   2            //On garde éteint pendant Lum_OFF millisecondes => On met LED à 0 et on ne rentre plus dans l'ISR penda
             -nt Lum_OFF secondes
 128   2            cptOFF++;
 129   2            LED = 0;
 130   2            TMR3RL = 0xFFFF - 10414; //On le met à la même période que le ON ((TMRRL dutyON + TMRRL dutyOFF )/ 2)
 131   2            Reset_Timer3Overflow;
 132   2            if ( cptOFF == 20*Lum_OFF) {
 133   3              currentNum++;
 134   3              cptON = 0; //Reset du compteur de Lum_ON pour son prochain allumage
 135   3            }
 136   2            return ; //On sort immédiatement de la fonction
 137   2          }
 138   1          //Gestion du rapport cyclique : Mode basique sans clignotement
 139   1        if(LED) {
 140   2          TMR3RL = 0xFFFF - t_on; // A terme, on veut pouvoir influencer ces valeurs de reload avec Intensite
 141   2        }
 142   1        else {
 143   2          TMR3RL = 0xFFFF - t_off; // On ne garde PAS à 65535, ça cause des erreurs
 144   2        }
 145   1        //Générateur de signaux
 146   1        LED = !LED;
 147   1        Reset_Timer3Overflow;
 148   1      }
 149          
 150          void Lumiere_Stop(void){
 151   1        //If (Réception du caractère d'extinction par l'UART) {
 152   1        //Disable_Timer3;   //Désactive le signal d'allumage du pointeur
 153   1        //}
 154   1      }
 155          //-----------------------------------------------------------------------------
 156          //-----------------------------------------------------------------------------
 157          // MAIN Routine
 158          //-----------------------------------------------------------------------------
 159          void main (void) {
 160   1             
 161   1          Init_Device();  // Appel des configurations globales
 162   1          
 163   1      // Début Insertion Code Configuration des périphériques ***********************
 164   1          EA = 1;
 165   1        
 166   1      // Fin Code Initialisations ***************************************************
 167   1          Reception();
 168   1        
 169   1      // Début Insertion Code Phase Démarrage *************************************** 
 170   1            
 171   1            
 172   1      // Fin Code phase Démarrage ***************************************************
 173   1        
 174   1        
 175   1        while(1)
 176   1              {
 177   2            Lumiere_Stop(); //On vérifie en permanence si on reçoit le caractère d'extinction
C51 COMPILER V9.59.0.0   FF_S1                                                             03/18/2021 08:53:31 PAGE 4   

 178   2              }                       
 179   1      }
 180          
 181          //-----------------------------------------------------------------------------
 182          //-----------------------------------------------------------------------------
 183          // Fonctions de configuration des divers périphériques
 184          //-----------------------------------------------------------------------------
 185          // Insérez vos fonctions de configuration ici
 186          
 187          //-----------------------------------------------------------------------------
 188          //-----------------------------------------------------------------------------
 189          // Fonctions d'interruptions
 190          //-----------------------------------------------------------------------------
 191          // Insérez vos fonctions d'interruption ici
 192          
 193          void ISR_timer3Overflow() interrupt 14
 194          {
 195   1          Lumiere(Intensite,Lum_ON, Lum_OFF, Lum_Nbre);
 196   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    748    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
